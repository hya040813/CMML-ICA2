---
title: "scAI: PBMC 3k RNA+ATAC integration"
author: "2141"
output: pdf_document
mainfont: Arial
vignette: >
  %\VignetteIndexEntry{Integrative analysis of single cell multi-omics data using scAI}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  root.dir = './'
)
```

This walkthrough will perform integrative analysis of paired single cell RNA-seq and ATAC-seq data of Cryopreserved human peripheral blood mononuclear cells (PBMCs) of a healthy female donor aged 25 were obtained by 10x Genomics from AllCells.
The data is downloaded from 10x Genomics.

1. Load the required libraries
```{r message=FALSE,warning=FALSE}
# Multi-omics integration package
library(scAI)
# Data processing and visualization packages
library(dplyr)
library(cowplot)
# Peak annotation related packages
library(AnnotationHub)
library(ChIPseeker)
library(org.Hs.eg.db)
```

2. Load data
The algorithm takes a list of two digital data matrices as input. Genes/loci should be in rows and cells in columns. rownames and colnames should be included. Before running the scAI model, we need to normalize the data to account for library size and select highly variable features.
```{r}
# Load preprocessed data list from RData file
load("D:/HuaweiMoveData/Users/hya/Desktop/CMML/ICA2/Results/scAI_input.Rda")
# Extract the original count matrix list X
X <- input_list$data # List of data matrix
```

3. Create a scAI object
```{r}
scAI_outs <- create_scAIobject(raw.data = X)
```

4. Preprocess data
Perform quality control to remove low-quality cells and genes, and normalize the data.
Since this is a preprocessed data, we do not need to normalize the data. Thus we set `assay = NULL`.
```{r, results='asis'}
scAI_outs <- preprocessing(scAI_outs, assay = NULL, minFeatures = 200, minCells = 1, libararyflag = F, logNormalize = F)
```

5. Run scAI model
As depending on the random initilization the results might differ, we run scAI multiple times (e.g. nrun = 5) and output the best result. User can also output results from all runs by setting *keep_all = TRUE*. The key parameters here are the number of component/clusters (k). The `selectK` function can aid in selecting k. A suitable k is the one at which the magnitude of cophenetic correlation begins to fall.
```{r}
# In order to reproduce the results, set random seeds first
set.seed(42)
# Run 6-factor decomposition, repeat 5 times, retain the optimal result
scAI_outs <- run_scAI(scAI_outs, K = 6, nrun = 5, keep_all = FALSE)
```

6. Visualized Biology Related Factors (Heatmap)
We plot the heatmap of the three learned low-rank matrices using hierarchical clustering. The time information of cells are used for validation.
```{r plot-lmHeatmap, fig.width=12, fig.height=14, fig.wide=TRUE, fig.align='center'}
# 6.1 Extracting the "Cell x Factor" Matrix: Transpose fit $H (originally K x cells)
joint_scores <- t(scAI_outs@fit$H)

# 6.2 Assign cell barcodes to matrix row names (from raw RNA data)  
rownames(joint_scores) <- colnames(scAI_outs@raw.data$RNA)

# 6.3 Perform K-means clustering on the factor space, assuming there are 6 groups
set.seed(123)
cell_clusters <- kmeans(joint_scores, centers = 6)$cluster

# 6.4 Fill in the clustering results with cell names
names(cell_clusters) <- rownames(joint_scores)

# 6.5 Package as data.frame to prepare for addpData
pdata_df <- data.frame(Cluster = cell_clusters,
                       row.names  = names(cell_clusters),
                       stringsAsFactors = FALSE)

# 6.6 Write back the pData slot of the scAI object
scAI_outs <- addpData(scAI_outs, pdata = pdata_df)

# 6.7 Draw three hierarchical clustering heatmaps of low rank matrices and color them according to Cluster
lmHeatmap(scAI_outs, color.by = "Cluster")
```

7. Visualize cells onto the low-dimensional space
We can visualize cells onto the low-dimensional space generated by t-SNE, FIt-sne or UMAP.
Here, we perform comparison of the visualization of raw ATAC-seq data with the aggregated data. Cells are colored by the collected time.
```{r umap-compare, fig.width=7, fig.height=3.5, fig.wide=TRUE, fig.align='center'}
# 7.1 Calculate the UMAP coordinates of the original scATAC
cell_coords_ori <- reducedDims(
  scAI_outs,
  data.use   = scAI_outs@norm.data$ATAC,
  do.scale   = FALSE,
  method     = "umap",
  return.object = FALSE
)

# 7.2 Calculate UMAP coordinates for aggregation (agg. data)
cell_coords_agg <- reducedDims(
  scAI_outs,
  data.use   = scAI_outs@agg.data,
  do.scale   = FALSE,
  method     = "umap",
  return.object = FALSE
)

# 7.3 Coloring the original scATAC seq with Cluster
gg1 <- cellVisualization(
  scAI_outs,
  cell_coords_ori,
  color.by    = "Cluster",
  show.legend = FALSE,
  title       = "scATAC-seq"
)

# 7.4 Coloring and aggregating scATAC with Cluster
gg2 <- cellVisualization(
  scAI_outs,
  cell_coords_agg,
  color.by    = "Cluster",
  ylabel      = NULL,
  title       = "Aggregated scATAC-seq"
)

# 7.5 Display two UMAP images side by side
cowplot::plot_grid(gg1, gg2)
```

8. Identify enriched features in each factor
```{r}
markers_RNA <- identifyFactorMarkers(scAI_outs, assay = 'RNA', n.top = 3)
markers_ATAC <- identifyFactorMarkers(scAI_outs, assay = 'ATAC', n.top = 3)
# Save ATAC top-3 peak table for future annotation/visualization
saveRDS(markers_ATAC$markers.top,
        file="D:/R download myself/CMML ICA2/markers_ATAC_top.rds")
```

9. Ranking the features (genes/loci) and highlighting the important markers in each factor
```{r, fig.width=4, fig.height=3,  fig.wide = TRUE, fig.align = "center"}
# 9.1 Read the annotated ATAC peak table
markers_annotated <- readRDS("D:/R download myself/CMML ICA2/markers_ATAC_annotated.rds") # get from motif.R

# 9.2 Constructing RNA annotation list: top-3_genes-by_actor
top3_genes_by_factor <- markers_RNA$markers.top$features
unique(top3_genes_by_factor)

# 9.3 Constructing ATAC peak and its gene symbol
top3_peaks_by_factor <- markers_annotated$features
top3_peak_symbols    <- markers_annotated$SYMBOL
unique(top3_peaks_by_factor)

# 9.4 RNA end marker gene with high brightness
featureRankingPlot(scAI_outs, assay = 'RNA', feature.show = top3_genes_by_factor, top.p = 0.5, ylabel = "Gene score")

# 9.5 Highlight the marker peak on the ATAC end and mark it with SYMBOL
featureRankingPlot(scAI_outs, assay = 'ATAC', feature.show = top3_peaks_by_factor, feature.show.names= top3_peak_symbols, top.p = 0.5, ylabel = "Locus score")
```

10. Visualization of the embedded cells, genes, loci and factors
User can provide a vector of the features (e.g., key marker genes/loci) to explore the biological meaning of the cell groups and enhance the interpretation of the data. 
```{r, fig.width=10,fig.height=4, fig.align = "center"}
# 10.1 Calculate the embedding coordinates of cells/genes/peaks/factors in 2D space
scAI_outs <- getEmbeddings(scAI_outs)

# 10.2 Only focus on gene highlighting
gg1 <- VscAIplot(scAI_outs, gene.use = top3_genes_by_factor, loci.use = NULL, color.by = "Cluster")

# 10.3 Only focus on peak highlighting
gg2 <- VscAIplot(scAI_outs, gene.use = NULL, loci.use = top3_peaks_by_factor, loci.use.names = top3_peak_symbols, color.by = "Cluster")

# 10.4 Side by side display
cowplot::plot_grid(gg1, gg2)
```

## Feature plot
We can overlay the expression of features onto the low-dimensional space, e.g., VscAI, tsne, umap
```{r, fig.width=9, fig.height=10,  fig.wide = TRUE, fig.align = "center"}
featureVisualization(scAI_outs, assay = "RNA", feature.use = top3_peak_symbols,  method = "VscAI", nCol = 4, cell.size = 0.2, show.legend = F, show.legend.combined = T)
```

11. Dual modality Heatmap
```{r}
library(ComplexHeatmap)
library(circlize)
library(dplyr)

# 11.1 Prepare the top 30 genes and peaks and their corresponding SYMBOLs
top_genes    <- markers_RNA$markers.top %>% pull(features) %>% unique() %>% head(30)
top_peaks    <- markers_annotated %>% pull(features)       %>% unique() %>% head(30)
peak_symbols <- markers_annotated %>% 
  filter(features %in% top_peaks) %>% 
  pull(SYMBOL)

# 11.2 Extract complete W1/W2 and make subsets
W1 <- scAI_outs@fit$W$RNA[top_genes,    , drop=FALSE]
W2 <- scAI_outs@fit$W$ATAC[top_peaks,   , drop=FALSE]

# 11.3 Set row and column names
rownames(W1) <- top_genes
rownames(W2) <- peak_symbols
colnames(W1) <- paste0("F", seq_len(ncol(W1)))
colnames(W2) <- paste0("F", seq_len(ncol(W2)))

# 11.4 Fixed column order and drawing
desired_order <- paste0("F", seq_len(ncol(W1)))
ht1 <- Heatmap(
  W1,
  name             = "RNA\nloading",
  cluster_rows     = TRUE,
  cluster_columns  = FALSE,
  column_order     = desired_order,
  show_row_names   = TRUE,
  row_names_gp     = gpar(fontsize = 6),
  row_names_side   = "left",
  show_column_names= TRUE
)
ht2 <- Heatmap(
  W2,
  name             = "ATAC\nloading",
  cluster_rows     = TRUE,
  cluster_columns  = FALSE,
  column_order     = desired_order,
  show_row_names   = TRUE,
  row_names_gp     = gpar(fontsize = 6),
  row_names_side   = "right",
  show_column_names= TRUE
)
draw(
  ht1 + ht2,
  heatmap_legend_side    = "right",
  annotation_legend_side = "right"
)
```

12
```{r}
# 1. 加载必要包
library(cluster)   # silhouette()

# 2. 提取“细胞 × 因子”矩阵并计算距离
Z    <- t(scAI_outs@fit$H)      # nCells × K
dmat <- dist(Z)                 # 欧氏距离

# 3. 取出聚类标签（直接从插槽里读）
clus <- as.numeric(factor(scAI_outs@pData$Cluster))

# 4. 计算 Silhouette
sil       <- silhouette(clus, dmat)
mean_sil  <- mean(sil[, "sil_width"])
cat("平均 Silhouette 宽度 =", round(mean_sil, 3), "\n")
plot(sil, border = NA, main = "Silhouette Plot")

# 5. 自定义 Dunn 指数函数
dunn_index <- function(distance, clusters) {
  d   <- as.matrix(distance)
  cls <- unique(clusters)
  # 最大簇内距离
  max_intra <- max(sapply(cls, function(c) {
    idx <- which(clusters == c)
    if (length(idx) > 1) max(d[idx, idx]) else 0
  }))
  # 最小簇间距离
  min_inter <- min(sapply(combn(cls, 2, simplify = FALSE), function(pair) {
    i1 <- which(clusters == pair[1])
    i2 <- which(clusters == pair[2])
    min(d[i1, i2])
  }))
  min_inter / max_intra
}

# 6. 计算并输出 Dunn 指数
dunn <- dunn_index(dmat, clus)
cat("Dunn 指数 =", round(dunn, 3), "\n")
```

